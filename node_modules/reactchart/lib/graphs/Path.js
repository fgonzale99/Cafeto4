'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var React = require('react');

var _ = require('underscore');
var space = require('../core/space-transf.js');
var imUtils = require('../core/im-utils.js');

/*
	 {
		show: true || false,
		ds: {
			x: {},
			y: {}
		},
		color: '',
		fill: '',
		width: ,
		shade: ,
		positions: [{x: , y: }],
		drops: [{x: , y: }],
		close: {
			x: true || false,
			y: true || false
		},
		dropLine: {
			x: true || false,
			y: true || false
		}
	}
*/

var Path = function (_React$Component) {
	_inherits(Path, _React$Component);

	function Path() {
		_classCallCheck(this, Path);

		return _possibleConstructorReturn(this, (Path.__proto__ || Object.getPrototypeOf(Path)).apply(this, arguments));
	}

	_createClass(Path, [{
		key: 'shouldComponentUpdate',
		value: function shouldComponentUpdate(props) {
			return !imUtils.isEqual(props.state, this.props.state);
		}
	}, {
		key: 'render',
		value: function render() {

			var state = this.props.state;

			if (state.show === false || state.positions.length === 0) {
				return null;
			}

			var ds = state.ds;
			var pos = state.positions;
			var drops = state.drops;

			var coord = function coord(idx) {
				return space.toC(ds.x, pos[idx].x) + ',' + space.toC(ds.y, pos[idx].y);
			};

			var dropx = function dropx(idx) {
				return space.toC(ds.x, drops[idx].x) + ',' + space.toC(ds.y, pos[idx].y);
			};

			var dropy = function dropy(idx) {
				return space.toC(ds.x, pos[idx].x) + ',' + space.toC(ds.y, drops[idx].y);
			};

			var points = 'M ' + coord(0);
			for (var i = 1; i < state.positions.length; i++) {
				points += ' L ' + coord(i);
			}

			// we close the curve if wanted
			// y dir has prevalence
			var filling = points;
			if (state.close.y) {
				for (var _i = drops.length - 1; _i >= 0; _i--) {
					filling += ' L ' + dropy(_i);
				}
			} else if (state.close.x) {
				for (var _i2 = drops.length - 1; _i2 >= 0; _i2--) {
					filling += ' L ' + dropx(_i2);
				}
			}
			filling += 'z';

			// droplines
			var dropLines = [];
			var color = state.color;
			var width = state.width;
			var shade = state.shade;

			if (state.dropLine.y) {
				dropLines = _.map(state.positions, function (pos, idx) {
					var path = 'M ' + coord(idx) + ' L ' + dropy(idx);
					var key = state.key + '.dl.' + idx;
					return React.createElement('path', { key: key, d: path, stroke: color, strokeWidth: width, opacity: shade });
				});
			}
			if (state.dropLine.x) {
				dropLines = _.map(state.positions, function (pos, idx) {
					var path = 'M ' + coord(idx) + ' L ' + dropx(idx);
					var key = state.key + '.dl.' + idx;
					return React.createElement('path', { key: key, d: path, stroke: color, strokeWidth: width, opacity: shade });
				});
			}

			return React.createElement(
				'g',
				null,
				state.close.y || state.close.x ? React.createElement('path', {
					d: filling,
					strokeWidth: 0,
					opacity: shade,
					fill: state.fill }) : null,
				React.createElement('path', {
					d: points,
					stroke: color,
					strokeWidth: width,
					opacity: shade,
					fill: 'none' }),
				dropLines
			);
		}
	}]);

	return Path;
}(React.Component);

module.exports = Path;