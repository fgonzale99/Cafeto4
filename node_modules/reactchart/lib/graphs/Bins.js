'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var React = require('react');

var _ = require('underscore');
var space = require('../core/space-transf.js');
var imUtils = require('../core/im-utils.js');
var utils = require('../core/utils.js');

/*
	{
		ds: {
			x: {},
			y: {}
		},
		color: '',
		fill: '',
		width: ,
		stairs: '',
		positions: [{x: , y: , fill: ''}], // start or end
		drops: [{x: , y: }],
		dropLine: {
			x: true || false,
			y: true || false
		}
	}
*/

var Bins = function (_React$Component) {
	_inherits(Bins, _React$Component);

	function Bins() {
		_classCallCheck(this, Bins);

		return _possibleConstructorReturn(this, (Bins.__proto__ || Object.getPrototypeOf(Bins)).apply(this, arguments));
	}

	_createClass(Bins, [{
		key: 'shouldComponentUpdate',
		value: function shouldComponentUpdate(props) {
			return !imUtils.isEqual(props.state, this.props.state);
		}
	}, {
		key: 'bin',
		value: function bin(point, drop, delta, idx) {

			var state = this.props.state;

			var p = {
				x: space.toC(state.ds.x, point.x),
				y: space.toC(state.ds.y, point.y)
			};

			var d = {
				x: space.toC(state.ds.x, drop.x),
				y: space.toC(state.ds.y, drop.y)
			};

			var del = space.toCwidth(state.ds.x, delta);

			var path = '';
			switch (state.stairs) {
				case 'right':
					var pr1 = p.x + ' ' + d.y;
					var pr2 = p.x + ' ' + p.y;
					var pr3 = p.x + del + ' ' + p.y;
					var pr4 = p.x + del + ' ' + d.y;
					path = 'M ' + pr1 + ' L ' + pr2 + ' L ' + pr3 + ' L ' + pr4;
					break;
				case 'left':
					var pl1 = p.x - del + ' ' + d.y;
					var pl2 = p.x - del + ' ' + p.y;
					var pl3 = p.x + ' ' + p.y;
					var pl4 = p.x + ' ' + d.y;
					path = 'M ' + pl1 + ' L ' + pl2 + ' L ' + pl3 + ' L ' + pl4;
					break;
			}

			var color = point.fill || state.fill;
			var shade = state.shade || 1;

			return React.createElement('path', { key: idx, d: path, strokeWidth: 0, fill: color, opacity: shade });
		}
	}, {
		key: 'path',
		value: function path() {

			var state = this.props.state;
			if (state.positions.length === 0) {
				return null;
			}
			var positions = state.positions;
			var ds = state.ds;
			var drops = state.drops;

			var coord = function coord(idx, idy) {
				idy = utils.isNil(idy) ? idx : idy;
				return space.toC(ds.x, positions[idx].x) + ',' + space.toC(ds.y, positions[idy].y);
			};

			var dropy = function dropy(idx) {
				return space.toC(ds.x, positions[idx].x) + ',' + space.toC(ds.y, drops[idx].y);
			};

			var dropx = function dropx(idx) {
				return space.toC(ds.x, drops[idx].x) + ',' + space.toC(ds.y, positions[idx].y);
			};

			var Nd = state.positions.length;
			var data = '';
			var delta = state.positions.length > 1 ? space.toCwidth(ds.x, positions[1].x - positions[0].x) : 10;
			switch (state.stairs) {
				case 'right':
					// right stairs
					data = (state.dropLine.y ? dropy(0) + ' ' : '') + coord(0);
					for (var i = 1; i < Nd; i++) {
						data += ' ' + coord(i, i - 1) + ' ' + coord(i);
						if (state.dropLine.y) {
							data += ' ' + dropy(i) + ' ' + coord(i);
						}
						if (state.dropLine.x) {
							data += ' ' + dropx(i) + ' ' + coord(i);
						}
					}
					data += ' ' + (space.toC(ds.x, positions[Nd - 1].x) + delta) + ',' + space.toC(ds.y, positions[Nd - 1].y); // point
					if (state.dropLine.y) {
						data += ' ' + (space.toC(ds.x, positions[Nd - 1].x) + delta) + ',' + space.toC(ds.y, drops[Nd - 1].y); // drop
					}
					break;
				case 'left':
					// left stairs
					if (state.dropLine.y) {
						data += space.toC(ds.x, positions[0].x) - delta + ',' + space.toC(ds.y, drops[0].y); // drop
					}
					data += ' ' + (space.toC(ds.x, positions[0].x) - delta) + ',' + space.toC(ds.y, positions[0].y); // point
					data += ' ' + coord(0);
					for (var _i = 1; _i < Nd; _i++) {
						if (state.dropLine.x) {
							data += ' ' + dropx(_i - 1) + ' ' + coord(_i - 1);
						}
						if (state.dropLine.y) {
							data += ' ' + dropy(_i - 1) + ' ' + coord(_i - 1);
						}
						data += ' ' + coord(_i - 1, _i) + ' ' + coord(_i);
					}
					data += state.dropLine.y ? ' ' + dropy(Nd - 1) : '';
					break;
				default:
					throw 'Stairs are either right or left';
			}

			return React.createElement('polyline', { points: data, stroke: state.color, strokeWidth: state.width, fill: 'none' });
		}
	}, {
		key: 'render',
		value: function render() {

			var state = this.props.state;
			var delta = state.positions.length > 1 ? state.positions[1].x - state.positions[0].x : 1;
			var me = this;

			return React.createElement(
				'g',
				null,
				_.map(state.positions, function (pos, idx) {
					return me.bin(pos, state.drops[idx], delta, idx);
				}),
				this.path()
			);
		}
	}]);

	return Bins;
}(React.Component);

module.exports = Bins;