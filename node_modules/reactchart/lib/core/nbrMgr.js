'use strict';

var pow = Math.pow,
    floor = Math.floor,
    log = Math.log,
    min = Math.min,
    max = Math.max,
    abs = Math.abs,
    LN10 = Math.LN10;


var suffixes = {
	18: 'E', // exa
	15: 'P', // peta
	12: 'T', // tera
	9: 'G', // giga
	6: 'M', // mega
	3: 'k', // kilo
	0: '', // unit
	'-3': 'm', // milli
	'-6': '\u03BC', // micro
	'-9': 'n', // nano
	'-12': 'p', // pico
	'-15': 'f', // femto
	'-18': 'a' // atto
};

var m = {};

var firstDigit = function firstDigit(r) {
	var res = r * pow(10, -m.orderMag(r));
	var str = '' + res;
	var out = str[0] || 0;
	return Number(out);
};

var firstNonNull = function firstNonNull(v) {
	var str = v + '';
	var com = str.indexOf('.');
	if (com < 0) {
		return 0;
	}
	var i = void 0,
	    out = void 0;
	for (i = str.length - 1; i >= 0; i--) {
		if (str[i] !== '0') {
			break;
		}
	}
	out = i - com;
	return max(out, 0);
};

var roundMe = function roundMe(min, max) {
	var valOrder = m.orderMag(max);
	var distOrd = m.orderMag(m.distance(max, min));

	var valid = function valid(cand) {
		return cand >= min && cand <= max;
	};

	var val = firstDigit(max) * pow(10, valOrder);
	if (!valid(val)) {
		if (distOrd < valOrder) {
			var step = pow(10, distOrd);
			return floor(min / step) * step + step;
		} else {
			// distOrd === valOrder
			return min;
		}
	}
	return val;
};

var scientific = function scientific(val, orMax) {
	var om = m.orderMag(val);
	var face = val / pow(10, om);
	while (face >= 10) {
		face /= 10;
		om += 1;
	}

	var maxV = max(om - orMax + 1, 0);
	var f = min(firstNonNull(face), maxV);

	return { base: face.toFixed(f), power: om };
};

var suffixe = function suffixe(order) {
	var num = order % 3 === 0 ? order : (order - 1) % 3 === 0 ? order - 1 : order - 2;
	return {
		num: num,
		string: suffixes[num]
	};
};

var natural = function natural(val, orMax) {
	var om = m.orderMag(val);

	var _suffixe = suffixe(om),
	    num = _suffixe.num,
	    string = _suffixe.string;

	var base = val / pow(10, num);
	while (base >= 1e3) {
		base /= 1e3;
		om += 3;
		string = suffixe(om).string;
	}

	var maxV = max(om - orMax + 1, 0);
	var comp = firstNonNull(base);
	var f = min(comp, maxV);

	return base.toFixed(f) + string;
};

var labelFromType = function labelFromType(type, dist) {

	switch (type) {
		case 'sci':
			return function (val) {
				return scientific(val, m.orderMag(dist));
			};
		case 'nat':
			return function (val) {
				return natural(val, m.orderMag(dist));
			};
		default:
			return function () {
				return false;
			};
	}
};

// distance methods
m.orderMag = function (r) {
	if (r < 0) {
		r = -r;
	}
	return r === 0 ? 0 : floor(log(r) / LN10);
};

m.orderMagValue = m.orderMagDist = function (max, min) {

	// zero case treated right away
	if (min * max < 0) {
		return 0;
	}
	var absMin = max < 0 ? Math.abs(max) : min;
	var absMax = max < 0 ? Math.abs(min) : max;
	var fac = max < 0 ? -1 : 1;
	return fac * roundMe(absMin, absMax);
};

m.roundUp = function (r) {
	var step = function step(val) {
		switch (firstDigit(val)) {
			case 2:
				return 5 * pow(10, m.orderMag(cand));
			default:
				return 2 * cand;
		}
	};
	var cand = pow(10, m.orderMag(r));
	while (cand <= r) {
		cand = step(cand);
	}

	var test = cand * pow(10, -m.orderMag(cand)); // between 0 and 1
	if (test > 6) {
		cand = pow(10, m.orderMag(cand) + 1);
	}
	return cand;
};

m.roundDown = function (r) {
	var step = 5 * pow(10, m.orderMag(r) - 1);
	var cand = firstDigit(r) * pow(10, m.orderMag(r));
	while (cand >= r) {
		cand -= step;
	}
	return cand;
};

// value methods
m.closestRoundUp = function (ref, dist) {

	if (ref < 0) {
		return -m.closestRoundDown(-ref, dist);
	}

	var refOm = m.orderMag(ref);
	var start = pow(10, refOm) * firstDigit(ref);
	while (start <= ref) {
		start += dist;
	}
	return start;
};

m.closestRoundDown = function (ref, dist) {

	var om = m.orderMag(dist);

	if (ref < 0) {
		return -m.closestRoundUp(-ref, om);
	}

	var refOm = m.orderMag(ref);
	var start = pow(10, refOm) * firstDigit(ref);
	if (refOm !== om) {
		while (start < ref) {
			start += dist;
		}
	}

	while (start >= ref) {
		start -= dist;
	}

	return start;
};

// value & distance methods
m.closestRound = function (ref, om, type) {
	return type === 'up' ? m.closestRoundUp(ref, om) : m.closestRoundDown(ref, om);
};

m.min = function (values) {
	return min.apply(null, values);
};

m.max = function (values) {
	return max.apply(null, values);
};

m.label = function (value, useless, fac) {
	return (value / fac).toFixed(1);
};

m.multiply = function (d, f) {
	return d * f;
};

m.divide = function (d, f) {
	return d / f;
};

m.increase = function (d1, d2) {
	return d1 + d2;
};

m.offset = function () {
	return (/*d*/0
	);
};

m.add = function (d1, d2) {
	return d1 + d2;
};

m.subtract = function (d1, d2) {
	return d1 - d2;
};

m.distance = function (d1, d2) {
	return abs(d1 - d2);
};

m.greaterThan = function (v1, v2) {
	return v1 > v2;
};

m.lowerThan = function (v1, v2) {
	return v1 < v2;
};

m.equal = function (v1, v2) {
	return v1 === v2;
};

// some management
m.extraTicks = function () {
	return [];
};

m.getValue = m.value = m.step = function (v) {
	return v;
};

m.smallestStep = function () {
	return 1;
};

// management
m.labelize = function (type, dist) {
	return labelFromType(type, dist);
};

m.labelF = 0.75;

m.type = 'number';

m.autoFactor = function (ma, mi) {
	var orMax = m.orderMag(ma);
	var orMin = m.orderMag(mi);
	var a = min(orMax, orMin);
	var b = max(orMax, orMin);

	return b - a < 3 ? pow(10, a) : pow(10, b);
};

module.exports = m;